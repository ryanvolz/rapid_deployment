#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Python wrappers for Lag Profile Matrix computations.

# Copyright (c) 2000-2003, University of Tromsï¿½ and Massachusetts
# Institute of Technology, All Rights Reserved
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License as
#  published by the Free Software Foundation; either version 2 of the
#  License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful, but
#  WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#  General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
#  USA

# $Id: Lpm.py 11043 2015-08-14 17:46:47Z brideout $

#import numpy.oldnumeric as Numeric
#import numpy.oldnumeric.mlab as MLab
import numpy.fft as FFT
import numpy
import PyLpm
import sys
import warnings

def stagger(data, scale = None):
    if scale is None:
        scale = numpy.amax(numpy.ravel(data))

    # Stagger data
    return data + scale * numpy.indices(data.shape)[0]

def selfNormalise(data):
    scale = numpy.amax(numpy.transpose(data))

    return numpy.transpose(numpy.transpose(data) / scale)

def fftshift(data):
    M, N = data.shape
    N1   = (N - 1)/2
    N2   = N - N1

    # Use numpy.concatenate instead
    shifted = numpy.zeros(data.shape, data.dtype.char)
    shifted[:,:N1] = data[:,N2:]
    shifted[:,N1:] = data[:,:N2]

    return shifted

def frqAxis(N, df = 1):
    return df * numpy.arange( -((N-1)/2), N/2+1, 1)



class LagProfileMatrix:
    """
    A Python interface to the lag profile matrix (LPM) computation classes
    for the Software Radar.  The LagProfileMatrix class embodies
    uncoded LPM computations, suitable for a single code of an
    alternating code set or an uncoded pulse (long pulse).  For coded
    pulses, some bookkeeping is done behind the scenes
    """

    def __init__(self, nZero, fractionality, integerLags):
        """
        Create a new LPM object.  Usage:

            lpm = LagProfileMatrix(nZero, fractionality, integerLags)

        nZero is the number of lag zero points, if == 0, length will be decided
            from the first data added
        fractionality is for alternating codes (use 1 for uncoded pulses),
        integerLags is the number of integer lags to compute
        """

        self.nZero         = nZero
        self.fractionality = fractionality
        self.integerLags   = integerLags
        self.weight        = 0

        if self.nZero != 0:
            self.length = PyLpm.length(nZero, fractionality, integerLags)
            self.lpm    = numpy.zeros(self.length, numpy.complex64)

    def LoadLPMData(self, data, weight):
        """
        Usage:
            lpm.LoadLPMData(data, weight)
        Set the lag product matrix data to <<data>> with weight <<weight>>.
        The incoming LPM data should be Complex64 format and
        in the correct sequence, as generated by some external
        agent.
        """

        if len(data) != self.length:
            raise ValueError, \
                  "lag product matrix data is wrong length (should be %d, is %d)" \
                  % (self.length, len(data))
        try:
            if data.dtype not in [numpy.dtype('float64'), numpy.dtype('complex64'), numpy.dtype('complex128')]:
                raise ValueError
        except ValueError, e:
            raise ValueError, "lag product matrix data is wrong type: %s" % (str(data.dtype))
        except AttributeError, e:
            raise ValueError, "lag product matrix data is not a numpy array"
        
        self.length = len(data)
        self.lpm = data
        self.weight = weight
        
        
    def getLagLpm(self, lag, fracLag=0):
        """getLagLpm returns a one-dimensional complex64 numpy array representing the lpm associated with the 
        requested lag and fractional lag (if not zero)
        
        Inputs: 
            lag - lag requested
            fracLag - fraction lag requested (default is 0)
               
        Raises ValueError  if no such lag in the lpm, or if illegal fractional lag.
        """
        
        if lag < 0 or lag >= self.integerLags:
            raise ValueError, 'lag %i does not exist in this LagProfileMatrix' % (lag)
        
        if fracLag >= self.fractionality:
            raise ValueError, 'fracLag must be less than self.fractionality'
        
        startIndex = PyLpm.startindex(self.nZero, self.fractionality, lag, fracLag)
        length = PyLpm.lplength(self.nZero, self.fractionality, lag, fracLag)
        return(self.lpm[startIndex:startIndex+length])
            
    
    def AcfMultiplyAccumulate(self, data):
        """
        Usage:
            lpm.AcfMultiplyAccumulate(data)
        Add <data> to the current LPM
        """
        if self.nZero == 0:
            self.nZero  = len(data)
            self.length = PyLpm.length(self.nZero,
                            self.fractionality, self.integerLags)
            self.lpm    = numpy.zeros(self.length, numpy.complex64)

        PyLpm.acfmac(self.lpm, self.nZero,
                self.integerLags * self.fractionality, data)
        self.weight += 1

    def AcfMatrixTrapezoidal(self, gating = 1, overlap = 0):
        """
        Usage:
            lpm.AcfMatrixTrapezoidal(gating = 1, overlap = 0)
        Extract range-averaged ACFs from the current LPM using a
        trapezoidal summation rule.

        'gating' determines the size of the summation trapezoid at zero
        lag.
        'overlap' determines the overlap between consecutive gates.
        
        """

        if overlap >= gating:
            raise ValueError, "overlap must be < gating"
        if gating > self.nZero - 2*(self.integerLags - 1):
            raise ValueError, "gating is too large - maximum possible: %d " % \
                  (self.nZero - 2*(self.integerLags - 1))

        return PyLpm.acfmatrix_trapezoidal(self.lpm, self.nZero, self.fractionality,
                                           self.integerLags, gating, overlap) / self.weight

    def getMaximumGatingAcfMatrixTrapezoidal(self):
        """
        Usage:
            lpm.getMaximumGatingAcfMatrixTrapezoidal()
        Return maximum possible gating for use with AcfMatrixTrapezoidal().
        This gating value will result in one ACF.
        """
        return self.nZero - 2*(self.integerLags - 1)


    def AcfMatrixInverseTrapezoidal(self, gating = 1, overlap = 0):
        """
        Usage:
            lpm.AcfMatrixInverseTrapezoidal(gating = 1, overlap = 0)
        Extract range-averaged ACFs from the current LPM using a
        inverse trapezoidal summation rule.
        
        WARNING: Use of the inverse trapezoidal summation rule has
        inferior statistical properties at long lags, and is therefore
        suboptimal!

        To get rid of warnings generated by this method, the caller
        can use the following code:
        warnings.filterwarnings('ignore', 'AcfMatrixInverseTrapezoidal',
                                DeprecationWarning, 'LagProfileMatrix')

        'gating' determines the size of the summation inverse
        trapezoid at zero lag.
        'overlap' determines the overlap between consecutive gates.
        """

        obsolete_warning = """

        The AcfMatrixInverseTrapezoidal() method of LagProfileMatrix
        is deprecated, and provided for comparison with legacy systems
        only.  Use of this summation rule has markedly inferior
        statistical properties at long lags.

        If you don't know what this message means, use the
        AcfMatrixTrapezoidal() method instead.  If you DO know what
        this means, consult the documentation for
        AcfMatrixInverseTrapezoidal() to determine how to get rid of
        this warning.

        """

        # register warning
        warnings.warn(obsolete_warning, DeprecationWarning)

        if overlap >= gating:
            raise ValueError, "overlap must be < gating"
        if gating > self.nZero:
            raise ValueError, "gating is too large - maximum possible: %d " % self.nZero

        return PyLpm.acfmatrix_inversetrapezoidal(self.lpm, self.nZero, self.fractionality,
                                                  self.integerLags, gating, overlap) / self.weight

    def getMaximumGatingAcfMatrixInverseTrapezoidal(self):
        """
        Usage:
            lpm.getMaximumGatingAcfMatrixInverseTrapezoidal()
        Return maximum possible gating for use with AcfMatrixInverseTrapezoidal().
        This gating value will result in one ACF.
        """
        return self.nZero


    def SpecMatrix(self, gating = 1, overlap = 0):
        """
        Usage:
            lpm.SpecMatrix(gating = 1, overlap = 0)
        Extract range-averaged spectra from the current LPM
        """
        # Extract one-sided ACF
        acfs = self.AcfMatrix(gating, overlap)

        # Symmetrise
        M, N  = acfs.shape

        # use numpy.concatenate instead
        S_acf = numpy.zeros((M, 2*N-2), acfs.dtype.char)
        S_acf[:,0:N] = acfs
        S_acf[:,N:]  = numpy.conj(acfs[:,-2:0:-1])

        return fftshift(FFT.fft(S_acf))

    def PlotAcf(self, plotter, gating = 1, overlap = 0):
        """
        Usage:
            lpm.PlotAcf(plotter, gating = 1, overlap = 0)
        Plot range-averaged ACFs from the current LPM.
        plotter must provide a plot() method
        """
        return plotter.plot(stagger(self.AcfMatrix(gating, overlap)))
    
    def PlotSpectra(self, plotter, gating = 1, overlap = 0, normalise = None):
        spc = self.SpecMatrix(gating, overlap).real

        if normalise is not None:
            spc = selfNormalise(spc)
            scale = 1
        else:
            scale = 0.6 * numpy.amax(numpy.ravel(spc))
        
        return plotter.plot(frqAxis(spc.shape[1]), stagger(spc, scale))

    def BackgroundSubtract_avg(self, bglpm):
        """
        Usage:
            lpm_bs = lpm.BackgroundSubtract_avg(bglpm)
        An LPM is created by subtracting a per-lag average of the supplied
        background from the current LPM.  The lpm and background must have
        the same number of lags, and be computed from an identical number
        of sample vectors at the same level.  The new LPM is returned
        """
        if self.integerLags != bglpm.integerLags:
            raise ValueError, "lpm and background must have same number of lags"

        if self.fractionality != 1:
            raise ValueError, "background subtraction is for integer lags only"

        if self.weight != bglpm.weight:
            raise UserWarning, "lpm and background has unequal weight"

        newLpm = LagProfileMatrix(self.nZero, 1, self.integerLags)
        newLpm.weight = self.weight

        for lag in range(self.integerLags):
            si     = PyLpm.startindex(self.nZero, 1, lag, 0)
            length = self.nZero - lag
            bg     = numpy.mean(bglpm.lpm[si:si+length])

            newLpm.lpm[si:si+length] = self.lpm[si:si+length] - bg

        return newLpm


    def BackgroundSubtract_point(self, bglpm):
        """
        Usage:
            lpm_bs = lpm.BackgroundSubtract_point(bglpm)
        An LPM is created by subtracting the supplied background from the
        current LPM on a point-by-point basis.  The lpm and background
        must have identical shape and size, and be computed from an
        identical number of sample vectors at the same level.
        The new LPM is returned
        """
        if self.nZero != bglpm.nZero or self.integerLags != bglpm.integerLags:
            raise ValueError, "lpm and background must have same shape and size"

        if self.weight != bglpm.weight:
            raise UserWarning, "lpm and background has unequal weight"

        newLpm = LagProfileMatrix(self.nZero, 1, self.integerLags)
        newLpm.weight = self.weight

        newLpm.lpm = self.lpm - bglpm.lpm

        return newLpm

    def PrintLpm(self):
        """
        prints out the LPM in a reasonable format for debugging.
        """
        print "(delay %d x lag %d), length %d" % (self.nZero, self.integerLags, len(self.lpm)),
        for lag in range(self.integerLags):
            print ""
            si = PyLpm.startindex(self.nZero, self.fractionality, lag, 0)
            # print "lag: ", lag, ", startindex: ", si
            for d in range(self.nZero-(lag*self.fractionality)):
                val = self.lpm[si + d]
                rv = val.real
                iv = val.imag
                print "%2.0f+%2.0fj|" % (rv,iv),
        print ""


class ResultLagProfileMatrix(LagProfileMatrix):
    """
    For coded pulses, the lpms for each scan of the code must be decoded
    and combined into a result lag profile matrix.  This class handles
    such combination and decoding.  After decoding all scans, the
    final result is obtained as res.lpm
    """


    def __init__(self, lpm):
        """
        Create a result lpm object using the properties of one of its
        intermediate lpms

            res = ResultLagProfileMatrix(lpm)
        """
        self.nZero         = lpm.nZero
        self.fractionality = lpm.fractionality
        self.integerLags   = lpm.integerLags

        self.length = PyLpm.rlength(self.nZero, self.fractionality,
                                self.integerLags)
        self.lpm    = numpy.zeros(self.length, numpy.complex64)

    def Decode(self, code, ilpm):
        """
        Add an intermediate lpm to the result lpm, using the given code
        for decoding

            res.Decode("++--+-+-", lpm)
        """
        PyLpm.decode(self.lpm, code, ilpm.weight, self.nZero,
                    self.fractionality, self.integerLags, ilpm.lpm)

    def DecodeWalshMethod(self, code_value, code_id, ilpm):
        """
        Add an intermediate lpm to the result lpm, using the given code
        for decoding. This is an implementation for alternating codes that
        does the decoding using Lehtinen's method only. No fractionality is
        supported at this time. The code_id is the number 0 to 31 of the
        scan code (SC).

        The code_value is the a_i alternating code representation from
        Lehtinen's thesis/paper. Note that they are in octal in the paper
        so be sure to convert them!

        """
        PyLpm.decode_walsh(self.lpm, code_value, code_id, ilpm.weight, self.nZero, self.integerLags, ilpm.lpm)

    def AcfMatrix(self, gating = 1, overlap = 0):
        """
        Usage:
            res.AcfMatrix(gating = 1, overlap = 0)
        Extract range-gate ACFs from the current result lpm
        """
        if overlap != 0:
            raise RuntimeError("Nonzero overlap not allowed for now")
        if self.fractionality != 1:
            raise RuntimeError("Can only extract result ACFs from integer lags")
        ngates = (self.nZero - self.integerLags + 1) / gating
        result = numpy.zeros([ngates, self.integerLags], numpy.complex)

        # Result lpms are already decoded to have identical range
        # ambiguities, all we need to do is average the given number of
        # columns.  Ignore partial gates for now
        for lag in range(self.integerLags):
            si = PyLpm.rstartindex(self.nZero, self.fractionality, lag, 0) \
                   + self.integerLags - 1 - lag

            g  = numpy.reshape(self.lpm[si:si+(ngates*gating)],
                    [ngates, gating])
            result[:,lag] = numpy.sum(numpy.transpose(g))
        
        return result
    def AcfMatrix_tobe(self, gating = 1, overlap = 0):
        """
        Usage:
            res.AcfMatrix_tobe(gating = 1, overlap = 0)
        Interface to C-level ACF extraction valid also for fractional lags
        """
        errorstring ="This interface depends on the weighting patch in the C routine lpm_fir_filter_one()."
        raise RuntimeError(errorstring)

        acfm = PyLpm.racfmatrix(self.lpm, self.nZero, self.fractionality,
                self.integerLags, gating, overlap)

        # Replace ambiguous zero-lag with one estimated from non-zero lags
        # using parabolic extrapolation
        # acfm[:,0] = ( 4*acfm[:,1].real - acfm[:,2].real ) / 3;
        return acfm

    def __printOneLP(self, ilag, flag):
        si = PyLpm.rstartindex(self.nZero, self.fractionality, ilag, flag)
        len = self.nZero - (ilag*self.fractionality + flag)
        print "(%2d,%+2d): [%3d]" %(ilag, flag, si),
        for k in range(len):
            val = self.lpm[si + k]
            print "%2.0f+%2.0fj|" % (val.real, val.imag),
        print ""

    def PrintLpm(self):
        """
        prints out the LPM in a reasonable format for debugging.
        """

        if self.fractionality == 1:
            print "(delay %d x lag %d), length %d" % (self.nZero, self.integerLags, len(self.lpm))
        else:
            print "(delay %d x lag %d (%d)), length %d" % \
                    (self.nZero, self.integerLags, self.fractionality, len(self.lpm))

        self.__printOneLP(0,0)
        for lag in range(1, self.integerLags):
            for flag in range(-self.fractionality+1, self.fractionality):
                self.__printOneLP(lag, flag)


class XLagProfileMatrix:

    def __init__(self, nZero, fractionality, integerLags):
        """
        Create a new cross-correlation lag profile matrix (XLPM).  Usage:

            xlpm = XLagProfileMatrix(nZero, fractionality, integerLags)

        nZero is the number of lag zero points, if == 0, length will be decided
            from the first data added
        fractionality is for alternating codes (use 1 for uncoded pulses),
        integerLags is the number of integer lags to compute
        """

        self.nZero         = nZero
        self.fractionality = fractionality
        self.integerLags   = integerLags
        self.weight        = 0

        if self.nZero != 0:
            self.length = PyLpm.xlength(nZero, fractionality, integerLags)
            self.lpm    = numpy.zeros(self.length, numpy.complex64)

    def XcfMultiplyAccumulate(self, data1, data2):
        """
        Usage:
            lpm.XcfMultiplyAccumulate(data)
        Add <data> to the current XLPM
        """
        if self.nZero == 0:
            self.nZero  = len(data1)
            self.length = PyLpm.xlength(self.nZero,
                            self.fractionality, self.integerLags)
            self.lpm     = numpy.zeros(self.length, numpy.complex64)

        PyLpm.xmac(self.lpm, self.nZero,
                self.integerLags * self.fractionality, data1, data2)
        self.weight += 1

    def XcfMatrixTrapezoidal(self, gating = 1, overlap = 0):
        """
        Usage:
            xlpm.XcfMatrix(gating = 1, overlap = 0)
        Extract range-averaged XCFs from the current XLPM
        """

        if overlap >= gating:
            raise ValueError, "overlap must be < gating"
        if gating > self.nZero - 2*(self.integerLags - 1):
            raise ValueError, "gating is too large - maximum possible: %d " % \
                  (self.nZero - 2*(self.integerLags - 1))

        return PyLpm.xcfmatrix_trapezoidal(self.lpm, self.nZero, self.fractionality,
                self.integerLags, gating, overlap) / self.weight

    def XSpecMatrix(self, gating = 1, overlap = 0):
        """
        Usage:
            xlpm.XSpecMatrix(gating = 1, overlap = 0)
        Extract range-averaged cross-spectra from the current XLPM
        """
        # Extract XCFs, discarding one point
        xcfs = self.XcfMatrix(gating, overlap)[:,1:]

        return fftshift(FFT.fft(xcfs))

    def PlotXcf(self, plotter, gating = 1, overlap = 0):
        """
        Usage:
            lpm.PlotAcf(plotter, gating = 1, overlap = 0)
        Plot range-averaged ACFs from the current LPM.
        plotter must provide a plot() method
        """
        return plotter.plot(stagger(self.XcfMatrix(gating, overlap).real))

    def PlotXSpectra(self, plotter, gating = 1, overlap = 0, normalise = None):
        spc = numpy.absolute(self.XSpecMatrix(gating, overlap))

        if normalise is not None:
            spc = selfNormalise(spc)
        
        return plotter.plot(frqAxis(spc.shape[1]), stagger(spc))


class ResultXLagProfileMatrix(XLagProfileMatrix):
    """
    For coded pulses, the xlpms for each scan of the code must be decoded
    and combined into a result cross-correlation lag profile matrix.  This
    class handles such combination and decoding.  After decoding all
    scans, the final result is obtained as res.xlpm
    """


    def __init__(self, xlpm):
        """
        Create a result xlpm object using the properties of one of its
        intermediate xlpms

            res = ResultXLagProfileMatrix(xlpm)
        """
        self.nZero         = xlpm.nZero
        self.fractionality = xlpm.fractionality
        self.integerLags   = xlpm.integerLags

        self.length = PyLpm.rxlength(self.nZero, self.fractionality,
                                self.integerLags)
        self.lpm    = numpy.zeros(self.length, numpy.complex64)

    def Decode(self, code, ixlpm):
        """
        Add an intermediate xlpm to the result xlpm, using the given code
        for decoding

            res.Decode("++--+-+-", ixlpm)
        """
        PyLpm.xdecode(self.lpm, code, ixlpm.weight, self.nZero,
                    self.fractionality, self.integerLags, ixlpm.lpm)

    def XcfMatrix(self, gating = 1, overlap = 0):
        """
        Usage:
            res.XcfMatrix(gating = 1, overlap = 0)
        Extract range-gate XCFs from the current result lpm
        """
        if overlap != 0:
            raise RuntimeError("Nonzero overlap not allowed for now")
        if self.fractionality != 1:
            raise RuntimeError("Can only extract result XCFs from integer lags")
        ngates = (self.nZero - self.integerLags + 1) / gating
        result = numpy.zeros([ngates, 2*self.integerLags-1], numpy.complex)

        # Result lpms are already decoded to have identical range
        # ambiguities, all we need to do is average the given number of
        # columns.  Ignore partial gates for now

        # Positive lags
        for lag in range(self.integerLags):
            si = PyLpm.rxstartindex(self.nZero, self.fractionality, \
                    self.integerLags, lag, 0) + self.integerLags - 1 - lag
            g  = numpy.reshape(self.lpm[si:si+(ngates*gating)],
                    [ngates, gating])
            result[:,lag] = numpy.sum(numpy.transpose(g))

        # Negative lags
        for lag in range(1, self.integerLags):
            si = PyLpm.rxstartindex(self.nZero, self.fractionality, \
                    self.integerLags, -lag, 0) + self.integerLags - 1 - lag
            g  = numpy.reshape(self.lpm[si:si+(ngates*gating)],
                    [ngates, gating])

            lgi = 2 * self.integerLags - lag - 1
            result[:,lgi] = numpy.sum(numpy.transpose(g))

        return result

    def XcfMatrix_tobe(self, gating = 1, overlap = 0):
        """
        Usage:
            res.XcfMatrix(gating = 1, overlap = 0)
        Extract range-gate ACFs from the current result lpm
        """

        errorstring ="This interface depends on the weighting patch in the C routine lpm_fir_filter_one()."
        raise RuntimeError(errorstring)

        return PyLpm.rxcfmatrix(self.lpm, self.nZero, self.fractionality,
                self.integerLags, gating, overlap)

    def __printOneLP(self, ilag, flag):
        si = PyLpm.rxstartindex(self.nZero, self.fractionality,
                self.integerLags, ilag, flag)
        len = self.nZero - abs(ilag*self.fractionality + flag)
        print "(%2d,%+2d): [%3d]" %(ilag, flag, si),
        for k in range(len):
            val = self.lpm[si + k]
            print "%2.0f+%2.0fj|" % (val.real, val.imag),
        print ""

    def PrintLpm(self):
        """
        prints out the LPM in a reasonable format for debugging.
        """

        if self.fractionality == 1:
            print "(delay %d x lag %d), length %d" % (self.nZero, self.integerLags, len(self.lpm))
        else:
            print "(delay %d x lag %d (%d)), length %d" % \
                    (self.nZero, self.integerLags, self.fractionality, len(self.lpm))

        for lag in range(-self.integerLags+1, 0):
            for flag in range(-self.fractionality+1, self.fractionality):
                self.__printOneLP(lag, flag)
        self.__printOneLP(0,0)
        for lag in range(1, self.integerLags):
            for flag in range(-self.fractionality+1, self.fractionality):
                self.__printOneLP(lag, flag)


tau0code16 = [
    "+-+++-+-----+++-",
    "+++++-+++----+++",
    "+--++--+++-++---",
    "++-++----+-+---+",
    "+-+-+---++++-+++",
    "+++-+--+-++++++-",
    "+---+-++--+----+",
    "++--+-+-+-+-+---",
    "+-++-----++-----",
    "++++---++++-+--+",
    "+--+--+++-++-++-",
    "++-+--+---++++++",
    "+-+---+-+--++--+",
    "+++---++---+----",
    "+------+-+--++++",
    "++------++---++-",
    "+-++++----+-+-++",
    "++++++-++-+---+-",
    "+--+++++++++++-+",
    "++-++++--+++-+--",
    "+-+-+++-++-+--+-",
    "+++-++++-+-++-++",
    "+---++-+-----+--",
    "++--++--+---++-+",
    "+-++-++--+---+-+",
    "++++-+++++--++--",
    "+--+-+-++--+--++",
    "++-+-+-----++-+-",
    "+-+--+--+-++++--",
    "+++--+-+--++-+-+",
    "+----+++-++-+-+-",
    "++---++-+++---++",
]


mhAltCode16   = [
    "++++++++++++++++",
    "+-++++---+--++-+",
    "++-+++--+++++-+-",
    "+--+++++-+--+---",
    "+++-++--+-+----+",
    "+-+-++++---+--++",
    "++--+++++-+--+--",
    "+---++-----+-++-",
    "++++-+--+---++--",
    "+-++-+++--+++++-",
    "++-+-++++---+--+",
    "+--+-+----+++-++",
    "+++--+++++-+--+-",
    "+-+--+---++-----",
    "++---+--++-+-+++",
    "+----+++-++--+-+",
    "+++++-+--+---++-",
    "+-+++--+++++-+--",
    "++-++--+-+----++",
    "+--++-+-++++---+",
    "+++-+--+---++---",
    "+-+-+-+-+-+-+-+-",
    "++--+-+----+++-+",
    "+---+--++-+-++++",
    "++++---+--++-+-+",
    "+-++--+-+----+++",
    "++-+--+---++----",
    "+--+---++-----+-",
    "+++---+--++-+-++",
    "+-+----+++-++--+",
    "++-----+-++-+++-",
    "+-----+-++-+++--",
]


mhAltCode32_ai = numpy.array([0,1,2,4,8,16,32,6,13,26,52,46,27,55,40,23,
                                47,24,49,36,15,31,62,58,51,33,5,11,22,44,30,61],'i')


mhAltCode16_ai = numpy.array([0,1,2,4,8,16,15,31,17,12,25,29,20,6,13,26],'i')



mhAltCode8  = [
    "++++++++",
    "+-+++--+",
    "++-++---",
    "+--++++-",
    "+++-++--",
    "+-+-+-+-",
    "++--+-++",
    "+---++-+",
    "++++-++-",
    "+-++----",
    "++-+---+",
    "+--+-+++",
    "+++--+-+",
    "+-+---++",
    "++----+-",
    "+----+--",
]

mhAltCode8_tmp = ["++++++++"]

mhAltCode8_ai = numpy.array([0,1,2,4,8,3,7,14],'i')

mhAltCode4   = [
    "++++",
    "+-++",
    "++-+",
    "+--+",
    "+++-",
    "+-+-",
    "++--",
    "+---",
]

mhAltCode4_ai = numpy.array([0,1,2,4],'i')

def test_lpm():
    codeset = mhAltCode16
    fractionality = 1
    integerLags   = len(codeset[0])
    lpm  = {}
    xlpm = {}


    # Initialise data structure
    for code in codeset:
        lpm[code]  =  LagProfileMatrix(0, fractionality, integerLags)
        xlpm[code] = XLagProfileMatrix(0, fractionality, integerLags)

    f = fractionality
    # Add some data
    for code in codeset:
        z = [ {'+': 1, '-': -1}[c] for c in code]
        z = numpy.ravel( [ {'+': (1,)*f, '-': (-1,)*f}[c] for c in code])
        print "code: ", code, ", adding ", z
        lpm[code].AcfMultiplyAccumulate(z)
        xlpm[code].XcfMultiplyAccumulate(z, z)
        # lpm[code].PrintLpm()

    result =  ResultLagProfileMatrix(lpm[codeset[0]])
    xresult = ResultXLagProfileMatrix(xlpm[codeset[0]])

    for code in codeset:
        print "adding lpm for code ", code
        result.Decode(code, lpm[code])
        xresult.Decode(code, xlpm[code])
    result.PrintLpm()
    xresult.PrintLpm()


    print "racf::"
    print(result.AcfMatrix())
    print "rxcf::"
    print(xresult.XcfMatrix())


def test_lpm_walsh():
    code_group = mhAltCode8
    code_ai = mhAltCode8_ai

    datalength = 40
    integerLags = 8
    fractionality = 1
    extra_delay = 3
    lpm = {}

     # Initialise data structure
    for code in code_group:
        lpm[code] = LagProfileMatrix(datalength, fractionality, integerLags)

    # Add some data
    for code in code_group:
        print len(lpm[code].lpm)
        z = numpy.array([])
        b = -(numpy.array(code,numpy.complex64)-44)
        for l in range(integerLags):
           mb = numpy.concatenate((numpy.zeros(extra_delay),b))
# two targets
           mb = numpy.concatenate((mb,mb))
           c = mb[l:]*mb[:len(mb)-l]
           z = numpy.concatenate((z,c))
           rz = datalength-len(c)-l
           z = numpy.concatenate((z,numpy.zeros(rz)))

#        w = len(code_group) * 1.0
        w = 1.0
        lpm[code].LoadLPMData(z,w)
        print "\ncode %s" % (code)
        print lpm[code].lpm

 

    result = ResultLagProfileMatrix(lpm[code_group[0]])
    result2 = ResultLagProfileMatrix(lpm[code_group[0]])

    test_array = numpy.zeros(len(lpm[code_group[0]].lpm),numpy.complex64)
    
    code_num = 0
    for code in code_group:
        test_array += lpm[code].lpm
        result.DecodeWalshMethod(code_ai, code_num, lpm[code])
        result2.Decode(code,lpm[code])
        code_num += 1


    print("done")

    print("\nWalsh Decoder : \n")
    result.PrintLpm()
# Don't do this it messes, the decoder range aligns
    print(result.AcfMatrixTrapezoidal(1,0))
    print("\nTom's Decoder : \n")
    result2.PrintLpm()
    print(result2.AcfMatrixTrapezoidal(1,0))                                    

    print "Array Undecoded Sum"
    print test_array

def test_xlpm():
    # datalength    = 200
    # fractionality = 4
    # integerLags   = 10
    datalength    = 20
    fractionality = 2
    integerLags   = 4
    xlpm = {}

    # Initialise data structure
    for code in mhAltCode16:
        xlpm[code] = XLagProfileMatrix(datalength, fractionality, integerLags)

    # Add some data
    import numpy.oldnumeric.random_array as RandomArray
    z1 = RandomArray.uniform(0., 1., (datalength)) \
            + 1j * RandomArray.uniform(0., 1., (datalength))
    z2 = RandomArray.uniform(0., 1., (datalength)) \
            + 1j * RandomArray.uniform(0., 1., (datalength))
    for code in mhAltCode16:
        xlpm[code].XcfMultiplyAccumulate(z1, z2)

    result = ResultXLagProfileMatrix(xlpm[mhAltCode16[0]])

    for code in mhAltCode16:
        result.Decode(code, xlpm[code])

    print(result.lpm)

      

def test_xcfmatrix():
    import numpy.oldnumeric.random_array as RandomArray
    from numpy.oldnumeric.mlab import ones

    datalength    = 20
    integerLags   = 5
    gating        = 2
    overlap       = 0

    z1 = RandomArray.uniform(0., 1., (datalength)) \
            + 1j * RandomArray.uniform(0., 1., (datalength))
    z2 = RandomArray.uniform(0., 1., (datalength)) \
            + 1j * RandomArray.uniform(0., 1., (datalength))

    z1 = ones(datalength)
    z2 = ones(datalength)

    xlpm = XLagProfileMatrix(datalength, 1, integerLags)
    xlpm.XcfMultiplyAccumulate(z1, z2)

    xcf = xlpm.XcfMatrix(gating, overlap)

    print(xlpm.lpm)
    print(xcf)


def test_acfmatrix():
    import numpy.oldnumeric.random_array as RandomArray

    datalength    = 20
    integerLags   = 5
    gating        = 2
    overlap       = 0

    z1 = RandomArray.uniform(0., 1., (datalength)) \
            + 1j * RandomArray.uniform(0., 1., (datalength))

    lpm = LagProfileMatrix(datalength, 1, integerLags)
    lpm.AcfMultiplyAccumulate(z1)

    acf = lpm.AcfMatrixTrapezoidal(gating, overlap)

    print(lpm.lpm)
    print(acf)

def test_acfmatrix_deterministic():
    lp = LagProfileMatrix(12,1,5)
    lp.lpm[0:12] = [1,2,3,4,5,6,7,8,9,10,11,12]
    lp.lpm[0:12].imag = [101,102,103,104,105,106,107,108,109,110,111,112]
    lp.lpm[12:23] = [20,21,22,23,24,25,26,27,28,29,30]
    lp.lpm[12:23].imag = [120,121,122,123,124,125,126,127,128,129,130]
    lp.lpm[23:33] = [40,41,42,43,44,45,46,47,48,49]
    lp.lpm[23:33].imag = [140,141,142,143,144,145,146,147,148,149]
    lp.lpm[33:42] = [60,61,62,63,64,65,66,67,68]
    lp.lpm[33:42].imag = [160,161,162,163,164,165,166,167,168]
    lp.lpm[42:50] = [80,81,82,83,84,85,86,87]
    lp.lpm[42:50].imag = [180,181,182,183,184,185,186,187]
    lp.weight = 1
    
    print "Lpm looks like:"
    lp.PrintLpm()
    
    for k in range(0,14):
        print "AcfMatrixTrapezoidal(%d,0) is: " % k
        try:
            print lp.AcfMatrixTrapezoidal(k,0)
        except Exception, e:
            print "Exception was thrown: " + traceback.format_exc()
        print "AcfMatrixInverseTrapezoidal(%d,0) is: " % k
        try:
            print lp.AcfMatrixInverseTrapezoidal(k,0)
        except Exception, e:
            print "Exception was thrown: " + traceback.format_exc()

    print "\n******\n  Overlap Tests \n*****\n"


    for k in range(0,5):
        print "AcfMatrixTrapezoidal(3,%d) is: " % k
        try:
            print lp.AcfMatrixTrapezoidal(3,k)
        except Exception, e:
            print "Exception was thrown: " + traceback.format_exc()
        print "AcfMatrixInverseTrapezoidal(3,%d) is: " % k
        try:
            print lp.AcfMatrixInverseTrapezoidal(3,k)
        except Exception, e:
            print "Exception was thrown: " + traceback.format_exc()
    

def test_bgsub():
    import numpy.oldnumeric.random_array as RandomArray

    datalength    = 20
    integerLags   = 5
    gating        = 2
    overlap       = 0

    lpm = LagProfileMatrix(datalength, 1, integerLags)

    for i in range(3):
        z1 = RandomArray.uniform(0., 1., (datalength)) \
            + 1j * RandomArray.uniform(0., 1., (datalength))

        lpm.AcfMultiplyAccumulate(z1)

    bga = lpm.BackgroundSubtract_avg(lpm)
    bgp = lpm.BackgroundSubtract_point(lpm)

    print(lpm.AcfMatrix(gating, overlap))
    print(bga.AcfMatrix(gating, overlap))
    print(bgp.AcfMatrix(gating, overlap))

def test_PlotSpectra():
    import numpy.oldnumeric.random_array as RandomArray
    import sys
    sys.path.append('../../Interfaces')
    import MultiPlot

    datalength    = 25
    integerLags   = 6
    gating        = 4
    overlap       = 0

    lpa =  LagProfileMatrix(datalength, 1, integerLags)
    lpb =  LagProfileMatrix(datalength, 1, integerLags)
    xlp = XLagProfileMatrix(datalength, 1, integerLags)

    for i in range(100):
        z1 = RandomArray.uniform(0., 1., (datalength)) \
            + 1j * RandomArray.uniform(0., 1., (datalength))
        z2 = RandomArray.uniform(0., 1., (datalength)) \
            + 1j * RandomArray.uniform(0., 1., (datalength))

        lpa.AcfMultiplyAccumulate(z1)
        lpb.AcfMultiplyAccumulate(z2)
        xlp.XcfMultiplyAccumulate(z1, z2)
    
    # bga = lpm.BackgroundSubtract_avg(bgm)
    # bgp = lpm.BackgroundSubtract_point(bgm)

    mp = MultiPlot.MultiPlot(3)

    lpa.PlotSpectra(mp, gating, overlap)
    lpb.PlotSpectra(mp, gating, overlap)
    xlp.PlotXSpectra(mp, gating, overlap)

    mp.display()



if __name__ == '__main__':
    # print "\nstartindex:"

    # print "%4d: %4d" % (   0, startindex(200, 1, 0,  0))
    # print "%4d: %4d" % ( 399, startindex(200, 1, 2,  0))
    # print "%4d: %4d" % (  27, startindex( 10, 2, 2, -1))
    # print "%4d: %4d" % ( 794, startindex(200, 4, 1,  0))
    # print "%4d: %4d" % ( 399, startindex(200, 4, 1, -2))
    # print "%4d: %4d" % ( 990, startindex(200, 4, 2, -3))
    # print "%4d: %4d" % (1185, startindex(200, 4, 2, -2))

    # print "\nrstartindex:"

    # print "%4d: %4d" % (   0, rstartindex(200, 1, 0,  0))
    # print "%4d: %4d" % ( 399, rstartindex(200, 1, 2,  0))
    # print "%4d: %4d" % (  34, rstartindex( 10, 2, 2, -1))
    # print "%4d: %4d" % ( 794, rstartindex(200, 4, 1,  0))
    # print "%4d: %4d" % ( 399, rstartindex(200, 4, 1, -2))
    # print "%4d: %4d" % (1572, rstartindex(200, 4, 2, -3))
    # print "%4d: %4d" % (1767, rstartindex(200, 4, 2, -2))

    test_lpm()
    # test_lpm_walsh()
    # test_acfmatrix()
    # test_acfmatrix_deterministic()
    # test_xcfmatrix()
    # test_bgsub()
    # test_PlotSpectra()
